Задача 9.
Дан массив положительных целых чисел arr. Дан еще массив от массивов от двух элементов xor_indices, в котором каждый 
элемент xor_indices[i][0] и xor_indices[i][1] представляет собой некоторый индекс. Требуется посчитать xor всех элементов, входящих 
в диапазон [xor_indices[i][0], xor_indices[i][1]]. (если xor_indices[i][0] == xor_indices[i][1], то возвращается только значение
arr[xor_indices[i][0]], а не 0).
Важно найти оптимальное, линейное решение, а не просто писать цикл от xor_indices[i][0] до xor_indices[i][1] и считать xor всех элементов)

Пример 1.
Вход: arr = [1,3,4,8], xor_indices = [[0,1],[1,2],[0,3],[3,3]]
Выход: [2,7,14,8] 
Объяснение: 
Двоичное представление элементов:
1 = 0001 
3 = 0011 
4 = 0100 
8 = 1000 
результат:
[0,1] = 1 xor 3 = 2 
[1,2] = 3 xor 4 = 7 
[0,3] = 1 xor 3 xor 4 xor 8 = 14 
[3,3] = 8

Пример 2.
Вход: arr = [4,8,2,10], xor_indices = [[2,3],[1,3],[0,0],[0,3]]
Выход: [8,0,4,4]

vector<int> xor_subarrays(vector<int>& arr, vector<vector<int>>& xor_indices)
{
	//решение
}

Задача 10.
Дан массив, в котором есть все неотрицательные целые числа диапазона [0, a.size()], кроме одного. Требуется за линейное время найти отсутствующее число.
Пример 1.
Вход: {3,0,1}
Выход: 2

Пример 2.
Вход: {0,1}
Выход: 2

Пример 3.
Вход: {9,6,4,2,3,5,7,0,1}
Выход: 8

int missing_number(vector<int>& nums) 
{
	// решение
}

Задача 11.
Дан массив неотрицательных целых чисел. Для каждого (непрерывного) подмассива sub_array = {arr[i], arr[i + 1], ..., arr[j]} (где i <= j) 
мы выполняем побитовое ИЛИ всех элементов в sub_array: {arr[i] | arr[i + 1] | ... | arr[j]}. Возвращать количество возможных результатов. 
Результаты, встречающиеся более одного раза, учитываются только один раз в окончательном ответе.

Пример 1.
Вход: arr = {0}
Выход: 1
Объяснение: There is only one possible result: 0.

Пример 2.
Вход: arr = {1,1,2}
Выход: 3
Объяснение: 
Всевозможные подмножества входного массива: {1}, {1}, {2}, {1, 1}, {1, 2}, {1, 1, 2}.
OR этих подмножеств: 1, 1, 2, 1, 3, 3.
Где только 3 различных значения, т.е. ответ: 3

Пример 3.
Вход: {1,2,4}
Выход: 6
Объяснение: 
Возможные результаты: 1, 2, 3, 4, 6 и 7.
int subarray_bitwise_ORs(vector<int>& arr)
{
	// решение
}

Задача 12.
Дан массив неотрицательных целых чисел, требуется найти arr[i] ^ arr[j] двух элементов, так что значение arr[i] ^ arr[j] максимальное среди всех пар arr[i] и arr[j].

Пример 1.
Вход: {3,10,5,25,2,8}
Выход: 28
Объяснение: Максимальный результат есть 5^25 == 28

Пример 2.
Вход: {14,70,53,83,49,91,36,80,92,51,66,70}
Выход: 127

int maximum_xor_pair(vector<int>& arr)
{
	// решение
}