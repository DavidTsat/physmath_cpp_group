Задача 1.

С помощью битовых операций проверить число на четность 
примеры 7 -> false, 4578 -> true
bool is_even(int x)
{
	return !(x & 1);
}

Задача 2.
Посчитать количество нулей в начале двоичного представления:
пример x = 784252715 (00101110101111101011111100101011) -> функция должна возвращать 2
int nulls_count(int x)
{
	for(int i = sizeof(int)*8 - 2; i >= 0; i--) {
		if(x & (1 << i)) {
			return sizeof(int)*8 - (i + 3);		
		}
	}

	return 31;
}

using hard-coded values like int i = 30 is not a good practice in C++, what if sizeof(int)*8 != 32 ? So a better generic solution would be int i = sizeof(int)*8-2. This is a small remark, but in C++ code it's important to not use hard-coded values.

Задача 3.
Даны числа x и i, требуется обнулить все биты числа x от самого старшeго до i.
Пример x = 784252715 (00101110101111101011111100101011), i = 13 -> функция должна возвращать 442155 (00000000000000000001111100101011)
		      
int clear_bits_through_i(int x, int y)
{
// again sizeof(int)*8 -2 is better than hard-coded 30
// --y is more appropriate in this case than y--, or to not use one more line, you can remove y-- and use i >= y -1 in the for loop.
//It's always better to compute something once and use it when needed instead of recomputing. So here `1 << i` can be computed only once
// and use it in both places.
// This solution is right, but you can also have a look at Hovhannes's solution as an alternative solution and also `x = x ^ (1 << i);` is 
// equivalent to the `x = x & ~(1 << i);` in our case right (since there is no any leading zero at the i-th step).
	for(int i = sizeof(int)*8 - 2; i >= (y - 1); i--) {
		if(x & (1 << i)) {
			x = x ^ (1 << i);
		}
	}

	return x;
}

// 2rd lucum

int clear_bits_through_i(int x, int y)
{
// This is a very solution, but why you convert it to long long and than convert it back to int ?
// just return x & ((1 << y) - 1) is not the same ?

// y = 31 i depqum 1 << 31 y int i sahmanneric durs kga dra hamar em long long sarqel heto int ov poxarinel
  return (int) ( (long long) x & ((1ll << y) - 1) );
}

Задача 4.
Пусть дано целочисленное значение short x, требуется возвращать его бинарное представление в std::string (порядок - big endian).
Алгоритм должен использовать битовые операции.
Примеры
0   -> "0000000000000000"
1   -> "0000000000000001"
7   -> "0000000000000111"
777 -> "0000001100001001"
513 -> "0000001000000001"
-7  -> "1111111111111001"

string short_to_binary_string(short x)
{
// Since Hovhannes's solution is similar, I'll just copy/paste my comment here for you too. https://github.com/DavidTsat/physmath_cpp_group/pull/1/files#r860872269
	string s;
	for(int i = sizeof(int)*8 - 2; i >= 0; i--) {
		if(x & (1 << i)) {
			s += "1";
		} else {
			s += "0";		
		}
	}

	return s;
}

Задача 5.

Обратная задача. Дана строка, длиной 32 элемента - двоичное представление некоторого целого неотрицательного числа, 
требуется возвращать это число с типом unsigned int.
Примеры
"0000000000000000" -> 0
"0000000000000001" -> 1
"0000000000000111" -> 7
"0000001100001001" -> 777
"0000001000000001" -> 513

unsigned binary_string_to_int(string s)
{
// again I will copy/paste my comment. It'll be useful for too https://github.com/DavidTsat/physmath_cpp_group/pull/1/files#r860871967
	unsigned answ = 0;
	
	for(int i = 0; i <= sizeof(int)*8 - 1; i++) {
		if(s[i] == '1') {
			answ += (1 << (sizeof(int)*8 - 1 - i));
		}
	}

	return answ;
}