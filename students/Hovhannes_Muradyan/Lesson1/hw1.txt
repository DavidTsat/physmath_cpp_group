Задача 1.
С помощью битовых операций проверить число на четность 
примеры 7 -> false, 4578 -> true
bool is_even(int x)
{
	return !(x&1);
}







Задача 2.
Посчитать количество нулей в начале двоичного представления:
пример x = 784252715 (00101110101111101011111100101011) -> функция должна возвращать 2
int nulls_count(int x)
{
  int counter = 0;
  for(int i = 30; i >=0 ; i--){
    if(x & (1<<i)){
      return counter;
    }
    counter++;
  }
}






Задача 3.
Даны числа x и i, требуется обнулить все биты числа x от самого старшeго до i.
Пример x = 784252715 (00101110101111101011111100101011), i = 13 -> функция должна возвращать 442155 (00000000000000000001111100101011)
# В примере ошибка , вместо 442155 должен быть 7979
int clear_bits_through_i(int x, int i)
{
  int a = INT32_MAX;
  a = a >> (31 - i);
  x = x & a;
  return x;
}




Задача 4.
Пусть дано целочисленное значение short x, требуется возвращать его бинарное представление в std::string (порядок - big endian).
Алгоритм должен использовать битовые операции.
Примеры
0   -> "0000000000000000"
1   -> "0000000000000001"
7   -> "0000000000000111"
777 -> "0000001100001001"
513 -> "0000001000000001"
-7  -> "1111111111111001"

string short_to_binary_string(short x)
{
  string k = "";
  for(int i = 31; i >=0;i--){
    if(x & (1<<i)){
      k+='1';
    }
    else
      k+='0';
  }
  return k;
}





Задача 5.

Обратная задача. Дана строка, длиной 32 элемента - двоичное представление некоторого целого неотрицательного числа, 
требуется возвращать это число с типом unsigned int.
Примеры
"0000000000000000" -> 0
"0000000000000001" -> 1
"0000000000000111" -> 7
"0000001100001001" -> 777
"0000001000000001" -> 513
"1111111111111001" -> -7
#Как unsigned int возвращает минусовое число?!

unsigned binary_string_to_int(string s)
{
  int x = 0;
  for(int i = 0; i < s.size();i++){
    if(s[i]- '0'){
      x+=(1<<(15-i));
    }
  }
  return x;
}
